# -*- coding: utf-8 -*-
"""FIX_Parser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fO2dI94xPTuuutHGp83HkhDn4zKnhdcj
"""

import pandas as pd
from datetime import datetime

class FIXParser:
    def __init__(self):
        # 1. The "Dictionary" (Ops Knowledge)
        # In real life, this is an XML spec, but we hardcode common tags here.
        self.tags = {
            '8': 'BeginString',
            '9': 'BodyLength',
            '35': 'MsgType',
            '49': 'SenderCompID',
            '56': 'TargetCompID',
            '34': 'MsgSeqNum',
            '52': 'SendingTime',
            '11': 'ClOrdID',   # Client Order ID
            '55': 'Symbol',
            '54': 'Side',
            '38': 'OrderQty',
            '40': 'OrdType',
            '44': 'Price',
            '59': 'TimeInForce',
            '10': 'CheckSum',
            '150': 'ExecType',
            '39': 'OrdStatus'
        }

        # Value maps (Translating codes like "1" to "Buy")
        self.values = {
            '35': {'D': 'New Order', '8': 'Execution Report', '3': 'Reject'},
            '54': {'1': 'Buy', '2': 'Sell', '5': 'Sell Short'},
            '39': {'0': 'New', '1': 'Partially Filled', '2': 'Filled', '8': 'Rejected'}
        }

    def parse_line(self, raw_fix):
        """
        Parses a single raw FIX string into a readable dictionary.
        Delimiter can be | or SOH (\x01)
        """
        # Handle different delimiters (pipes or SOH characters)
        if '|' in raw_fix:
            delimiter = '|'
        else:
            delimiter = '\x01'

        pairs = raw_fix.split(delimiter)
        parsed_msg = {}

        for pair in pairs:
            if '=' in pair:
                tag, val = pair.split('=', 1)

                # Get the English Tag Name (e.g., 55 -> Symbol)
                tag_name = self.tags.get(tag, f"Tag_{tag}")

                # Get the English Value (e.g., 54=1 -> Buy)
                # Check if this tag has a value map
                if tag in self.values and val in self.values[tag]:
                    val_readable = f"{val} ({self.values[tag][val]})"
                else:
                    val_readable = val

                parsed_msg[tag_name] = val_readable

        return parsed_msg

# --- MAIN EXECUTION ---

# 1. Initialize the Parser
decoder = FIXParser()

# 2. Dummy Data (Raw Logs you might see in Ops)
raw_logs = [
    "8=FIX.4.2|35=D|49=CLIENT|56=CITADEL|11=ORD_001|55=NVDA|54=1|38=100|40=2|44=450.00|59=0|10=123|",
    "8=FIX.4.2|35=8|49=CITADEL|56=CLIENT|11=ORD_001|150=0|39=0|55=NVDA|38=100|44=450.00|10=234|",
    "8=FIX.4.2|35=3|49=CITADEL|56=CLIENT|45=2|58=Unknown Symbol|10=001|"
]

# 3. Process the Logs
parsed_data = []
for log in raw_logs:
    readable = decoder.parse_line(log)
    parsed_data.append(readable)

# 4. Convert to DataFrame for easier reading
df_log = pd.DataFrame(parsed_data)

# Reorder columns to put important stuff first (Ops Logic)
cols = ['MsgType', 'Symbol', 'Side', 'OrderQty', 'Price', 'OrdStatus']
# Only select cols that exist in the data
existing_cols = [c for c in cols if c in df_log.columns]
remaining_cols = [c for c in df_log.columns if c not in existing_cols]

df_final = df_log[existing_cols + remaining_cols]

# 5. Display
print("--- Decoded FIX Logs ---")
print(df_final.to_string())

# 6. Save to CSV
df_final.to_csv('decoded_fix_logs.csv', index=False)